package com.cy.example.utils;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.util.ArrayList;import java.util.Collection;import java.util.List;import java.util.Random;import java.util.zip.GZIPInputStream;import java.util.zip.GZIPOutputStream;import sun.misc.BASE64Decoder;import sun.misc.BASE64Encoder;public class StringUtil {	public static String _blank = " ";	protected static final String _NextLineTag = "/n";	private static Random rnd = null;	private static long feed = 0L;	public static boolean isInteger(String s) {		if (s == null || "".equals(s))			return false;		boolean pointExists = false;		boolean ok = true;		for (int i = (s.startsWith("-") ? 1 : 0); i < s.length(); i++) {			String sValue = s.substring(i, i + 1);			if ("0123456789.".indexOf(sValue) < 0) {				ok = false;				break;			} else {				if (sValue.equals(".")) {					if (pointExists) {						ok = false;						break;					} else {						pointExists = true;					}				}			}		}		return ok;	}	/**	 * 方法说明： 该函数获得随机数字符串	 * 	 * @param iLen	 *            int :需要获得随机数的长度	 * @param iType	 *            int:随机数的类型：'0':表示仅获得数字随机数；'1'：表示仅获得字符随机数；'2'：表示获得数字字符混合随机数	 * @param feed	 *            int :需要获得随机数的种子数	 * @since 1.0.0	 */	public static final String CreateRadom(int iLen, int iType, int feed) {		String strRandom = "";// 随机字符串		Random rnd = new Random(feed);		if (iLen < 0) {			iLen = 5;		}		if ((iType > 2) || (iType < 0)) {			iType = 2;		}		switch (iType) {		case 0:			for (int iLoop = 0; iLoop < iLen; iLoop++) {				strRandom += Integer.toString(rnd.nextInt(10));			}			break;		case 1:			for (int iLoop = 0; iLoop < iLen; iLoop++) {				strRandom += Integer.toString((35 - rnd.nextInt(10)), 36);			}			break;		case 2:			for (int iLoop = 0; iLoop < iLen; iLoop++) {				strRandom += Integer.toString(rnd.nextInt(36), 36);			}			break;		}		return strRandom;	}	private static void randomize() {		if (System.currentTimeMillis() - feed > 36E6) {// 一个小时			rnd = new Random(feed = System.currentTimeMillis());		}	}	public static final String CreateRadom(int iLen, int iType) {		StringBuffer sb = new StringBuffer();		randomize();		if (iLen < 0) {			iLen = 5;		}		if ((iType > 2) || (iType < 0)) {			iType = 2;		}		switch (iType) {		case 0:			for (int iLoop = 0; iLoop < iLen; iLoop++) {				sb.append(Integer.toString(rnd.nextInt(10)));			}			break;		case 1:			for (int iLoop = 0; iLoop < iLen; iLoop++) {				sb.append(Integer.toString((35 - rnd.nextInt(10)), 36));			}			break;		case 2:			for (int iLoop = 0; iLoop < iLen; iLoop++) {				sb.append(Integer.toString(rnd.nextInt(36), 36));			}			break;		}		return sb.toString();	}	public static void clearStringBuffer(StringBuffer strBuff) {		strBuff.delete(0, strBuff.length());	}	public static String setStrFirstCharLowCase(String str) {		str = str.substring(0, 1).toLowerCase() + str.substring(1);		return str;	}	/**	 * 数据压缩	 * 	 * @param str	 *            要压缩的数据	 * @param encode	 *            要压缩数据的编码格式	 * @return 压缩后数据	 * @throws IOException	 */	public static String compress(String str, String encode) throws IOException {		if (str == null || str.length() == 0) {			return "";		}		byte[] tArray;		ByteArrayOutputStream out = new ByteArrayOutputStream();		GZIPOutputStream gzip = new GZIPOutputStream(out);		try {			gzip.write(str.getBytes(encode));			gzip.flush();		} finally {			gzip.close();		}		tArray = out.toByteArray();		out.close();		BASE64Encoder tBase64Encoder = new BASE64Encoder();		return tBase64Encoder.encode(tArray);	}	public static String gzipCompress(String str) throws IOException {		if (str == null || str.length() == 0) {			return "";		}		byte[] array = null;		ByteArrayOutputStream out = new ByteArrayOutputStream();		GZIPOutputStream gzip = new GZIPOutputStream(out);		try {			gzip.write(str.getBytes());			gzip.flush();		} finally {			gzip.close();		}		array = out.toByteArray();		out.close();		return new String(array, "iso-8859-1");	}	public static String gzipUncompress(String str) throws IOException {		if (str == null || str.length() == 0) {			return "";		}		ByteArrayOutputStream out = new ByteArrayOutputStream();		ByteArrayInputStream in = new ByteArrayInputStream(				str.getBytes("iso-8859-1"));		GZIPInputStream gunzip = new GZIPInputStream(in);		try {			byte[] buffer = new byte[256];			int n;			while ((n = gunzip.read(buffer)) >= 0) {				out.write(buffer, 0, n);			}		} finally {			gunzip.close();		}		in.close();		out.close();		return out.toString("iso-8859-1");	}	public static String uncompress(String str) throws IOException {		return uncompress(str, "UTF-8");	}	public static String uncompress(String str, String encode)			throws IOException {		if (str == null || str.length() == 0) {			return "";		}		BASE64Decoder tBase64Decoder = new BASE64Decoder();		byte[] t = tBase64Decoder.decodeBuffer(str);		ByteArrayOutputStream out = new ByteArrayOutputStream();		ByteArrayInputStream in = new ByteArrayInputStream(t);		GZIPInputStream gunzip = new GZIPInputStream(in);		try {			byte[] buffer = new byte[256];			int n;			while ((n = gunzip.read(buffer)) >= 0) {				out.write(buffer, 0, n);			}		} finally {			gunzip.close();		}		in.close();		out.close();		return out.toString(encode);	}	/**	 * 判断字符串是否为空	 * 	 * @param value	 *            字符串	 * @return	 * @author leeyu20140506	 */	public static boolean IsNullOrEmpty(String value) {		return value == null || "".equals(value);	}		/**	 * 判断两个字符串是否相等	 * 	 * @param value	 *            字符串	 * @return	 * @author leeyu20140506	 */	public static boolean IsEmpty(String value,String value1) {		if(value == null && value1 == null){			return true;		}else if(value != null){			return value.equals(value1);		}else{			return value1.equals(value);		}	}	/**	 * 判断字符串是否为空（去空格后）	 * 	 * @param value	 *            　字符串	 * @return	 * @author leeyu20140506	 */	public static boolean IsNullOrEmptyT(String value) {		// /// by weijj 全角空格 替换半角空格后 trim		return value == null || "".equals(value.replaceAll("　", " ").trim());	}	/**	 * 过滤字符串的全部空白字符<br />	 * 	 * @param text	 * @return	 * @author huangsq	 */	public static String trimAll(String text) {		return text.replaceAll("\\s*", "");	}	/**	 * 将集合数据根据分隔符连接成字符串<br />	 * 	 * @param arrays	 *            对像列表	 * @param separator	 *            分隔符，默认为",";	 * @return	 * @author huangsq	 */	public static String join(String separator, Object... arrays) {		String result = "";		if (arrays == null) {			return result;		}		if (separator == null) {			separator = ",";		}		StringBuilder sBuilder = new StringBuilder();		for (Object object : arrays) {			if (object instanceof Collection<?>) {				Collection<?> list = (Collection<?>) object;				for (Object obj : list) {					sBuilder.append(obj).append(separator);				}			} else {				sBuilder.append(object).append(separator);			}		}		if (sBuilder.length() >= separator.length()) {			result = sBuilder.substring(0,					sBuilder.length() - separator.length());		}		return result;	}	/**	 * 将列表数据组装成字符串	 * 	 * @param list	 *            　列表	 * @param separator	 *            　分隔符	 * @return	 * @throws Exception	 *             当separator为空	 * @author leeyu20140506	 */	public static String join(Collection<String> list, String separator)			throws Exception {		String str = "";		if (separator == null) {			separator = ",";		}		StringBuffer buf = new StringBuffer();		try {			if (list != null && list.size() > 0)				for (String s : list) {					buf.append(s).append(separator);				}			if (buf.length() >= separator.length()) {				str = buf.substring(0, buf.length() - separator.length());			}		} catch (Exception ex) {			throw ex;		} finally {			buf.delete(0, buf.length());			buf = null;		}		return str;	}	/**	 * 将字符串数组组装成字符串	 * 	 * @param value	 *            字符串数组	 * @param separator	 *            分隔符	 * @return	 * @throws Exception	 *             当separator为空	 * @author leeyu20140506	 */	public static String join(String[] value, String separator)			throws Exception {		String str = "";		if (separator == null) {			separator = ",";		}		StringBuffer buf = new StringBuffer();		try {			if (value != null && value.length > 0)				for (String s : value) {					buf.append(s).append(separator);				}			if (buf.length() >= separator.length()) {				str = buf.substring(0, buf.length() - separator.length());			}		} catch (Exception ex) {			throw ex;		} finally {			buf.delete(0, buf.length());			buf = null;		}		return str;	}	/**	 * 将字符串拆分成字符串数组	 * 	 * @param value	 *            　字符串	 * @param separator	 *            　分隔符	 * @return	 * @throws Exception	 *             当separator为空	 * @author leeyu20140506	 */	public static List<String> split(String value, String separator)			throws Exception {		List<String> list = null;		if (separator == null) {			separator = ",";		}		try {			if (!IsNullOrEmpty(value)) {				list = new ArrayList<String>();				String[] args = value.split(separator);				for (String s : args) {					list.add(s);				}			}		} catch (Exception ex) {			throw ex;		}		return list;	}	/**	 * 得到一个字符串的长度,显示的长度,一个汉字或日韩文长度为2,英文字符长度为1	 * 	 * @param s	 *            需要得到长度的字符串	 * @return i得到的字符串长度	 */	public static int length(String s) {		if (s == null) {			return 0;		}		char[] c = s.toCharArray();		int len = 0;		for (int i = 0; i < c.length; i++) {			len++;			// 如果为汉，日，韩，则多加一位			if (!isLetter(c[i])) {				len++;			}		}		return len;	}	/**	 * 判断一个字符是Ascill字符还是其它字符（如汉，日，韩文字符）	 * 	 * @param c	 *            需要判断的字符	 * @return 返回true,Ascill字符	 */	public static boolean isLetter(char c) {		int k = 0x80;		return c / k == 0 ? true : false;	}}